  let a = [1,2]
  type Age = number
  type Player = {
    name : string,
    age? : Age
  }
  const suhyun : Player = {
    name : "suhyun"
  }

  function playerMaker(name:string) : Player{
    return {
        name
    }
  }
  const junghyun = playerMaker("junghyun")
  junghyun.age = 24

  const playerMaker2 = (name : string) :Player => ({name})

  type Add = (a:number, b: number) => number;
  const add:Add = (a,b) => a+b

  type Config = {
    path : string,
    state : object
  }
  //오버로딩 예시 
  type Push = {
    (path:string):void
    (config : Config) : void
  }

  const push : Push = (config) => {
    if(typeof config === "string"){
      console.log(config)
    }
    else{
      console.log(config.path)
    }
  }

//
  type Add2 = {
    (a:number, b : number) : number
    (a:number , b: number, c : number) : number
  }
  const add2 : Add2 = (a,b,c?:number) => {
    if(c) return a+b+c
    return a+b 
  }

//polyMorphism
  type SuperPrint = {
    (arr:number[]) : void
    (arr:boolean[]) : void
  }
  const superPrint : SuperPrint = (arr) => {
    arr.forEach(i => {
      console.log(i)
    })
  }
  superPrint([1,2,3,4])
  superPrint([true,false,true])

  //call signature를 작성할 때 들어올 확실한 타입을 모를 때 generic을 사용한다. 

type SuperPrint2 = {
  <TypePlaceholder>(arr : TypePlaceholder[]) : void
}
  const superPrint2 : SuperPrint2 = (arr) => {
    arr.forEach(i => {
      console.log(i)
    })
  }
superPrint2([1,2,3,4])
superPrint2([true,false,true])
superPrint2(["1",2,true,[1,2]])

//polyMorphism. generic
type SuperPrint3 = {
  <placeholder>(arr : placeholder[]) : placeholder
}
const superPrint3 : SuperPrint3 = arr => arr[0]
const returnA = superPrint3(['1',2,3])
const returnB = superPrint3([1,2,3])
const returnC = superPrint3([true, 1, false])

//타입스크립트가 타입을 유추하게 한다. 배열임을 알고, 그 원소 중 하나를 return 한다는 것을 
//call-signature를 통해 정의하였다. 
type SuperPrintA = {
  <T>(arr : T[]) : T
}

type SuperPrintB = <T,M>(a:T[], b:M) => T   //첫번째 param은 배열, 두번째 param은 단일 값.
//any와 다르다. 요청에 따라 call signature를 생성한다는 뜻. 

//라이브러리를 만들거나, 다른 개발자가 사용할 기능을 개발하는 경우에 제너릭이 유용!

function superPrintC<V>(a:V[]){
  return a[0]
}
const a1 = superPrintC([1,2,3,4])
const b1 = superPrintC([true, false,true])
const c1 = superPrintC([1,2,true,false,"hello"])
//
//제너릭 받아서 사용. 확장.
type Person<E> = { //많은 것 중 하나가 다른 타입을 가질 수 있거나, 커스텀 타입 사용할 때. 
  name : string
  extraInfo : E
}
type NicoExtra = {
  favFood : string
}
type NicoPlayer = Person<NicoExtra>
type PersonA = Person<{favFood:string}>

const nico : Person<{favFood:string}> = { //const nico : PersonA 
  name : "nico",
  extraInfo : {
    favFood : "kimchi"
  }
}

const lynn : Person<null> = { //name은 갖지만 extraInfos는 없다고 한다. 
  name : "lynn",
  extraInfo : null
}

//제너릭 예제
type A = Array<number>  //interface Array<T>var Array : ~ .Array는 제너릭을 받는다. 
let aA :A = [1,2,3,4]

// == number[]
function printAllNumbers(arr:Array<number>){ // number[]

}
//react.js 
//useState<number>

////////class
abstract class User{ //추상 클래스, 다른 클래스가 상속받을 수 있는 클래스 . 직접 새 인스턴스 x. 
    constructor(
        //private firstName : string, //private은 상속해도 자식 클래스에서 접근 불가. 인스턴스 밖에서 접근 불가.
        protected firstName : string,
        private lastName : string, //외부로부터는 보호되고, 자식 클래스에섯 사용되기를 원하면 protected를 쓴다. 
        private nickname : string
    ){}
    abstract getNickName():void //추상 메소드, 추상 클래스를 상속받는 것들이 구현해야 함. 
    getFullName(){
        return `${this.firstName} ${this.lastName}`
    }
}

class PlayerE extends User {
    getNickName(){console.log(this.firstName)}
}

const suhyun2 = new PlayerE('shim','suhyun','suhyun')
//suhyun.firstName . private 불가. protected도 불가. 외부는 둘다 모두 불가. public을 사용해야 함. 